#!/bin/bash

# bsed's Functions and Variables

# Vars
__cwd="$(pwd)"
prgroot="$HOME/.bsed"

# Declare associative arrays
declare -A lists
declare -A states

# Preset associative values
states[cfg]="" # Any text within a bool state signifies true, less is better
lists[cmds]="^(format|config|verbose|help|version)$"

# Variables to be interpolated into the built regex
xwildchar='[\^\.]\*'
xwilddigit='[[:digit:]]\*'
xwhitespace='[[:space:]]\*'

# Output functions
error() { echo -e '\e[0;1;31m[ERROR]\e[0;0;0m '$1 >&2; }
verbose() { [[ -n "$VERBOSE" ]] && echo -e '\e[0;1;35m[VERBOSE]\e[0;0;0m '$"$1"; }
log() { echo -e '\e[0;1;32m[BSED]\e[0;0;0m '$1; }

# Processing functions
__args() {
	# Process args
	[[ -z "$1" ]] && cat "$prgroot"/help | head -1 && exit
	while [[ -n "$1" ]]; do
		case "${1}" in
			-f | --format )
				shift
				[[ -z "$1" ]] && echo "No format specified" && exit
				states[format]="${1}"
				;;
			-C | --config )
				shift
				states[cfg]="t"
				;;
			--reset-cfg )
				log "Resetting bsed to default configuration..."
				cp -rf $(find "$HOME" -type d -name bsed 2>/dev/null | head -1)/.bsed "$HOME/" && echo "bsed's config has been reset!" || error "Failed to reset defaults!"
				exit;;
			--verbose | -V )
				VERBOSE=true
				;;
			-\? | --help )
				# Not using -h to leave it open for other possible args
				cat "$prgroot/help"
				exit;;
			--version | -v )
				cat "$prgroot/version"
				exit;;
			* )
				# Catch-all
				if [[ "$1" =~ ${lists[cmds]} ]]; then
					__cmds "$1"
					return 0
				else
					cat "$prgroot/help" | head -1
					error "'$1' is not an argument!"
					exit
				fi
				;;
		esac
	shift; done
}

__cmds() {
	# Process commands
	[[ -z "$1" ]] && cat "$prgroot"/help | head -1 && exit
	while [[ -n "$1" ]]; do
		case "${1,,}" in
			format )
				shift
				[[ -z "$1" ]] && echo "No format specified" && exit
				states[format]="${1}"
				;;
			config )
				shift
				states[cfg]="t"
				;;
			verbose )
				shift
				VERBOSE=true
				;;
			help ) # Not using -h to leave it open for other possible args
				cat "$prgroot/help"
				exit;;
			version )
				cat "$prgroot/version"
				exit;;
			* ) # Catch-all
				if [[ "$1" =~ ^- ]]; then
					__args "$1"
					return 0
				else
					verbose "Grepped command: '$(echo "${lists[cmds]}" | sed -e 's/\^\|[\(]\|[\)]\|\$//g' -e 's/[\|]/\n/g' | grep "$1")'"
					error "'$1' is not a command!"
					error "Did you mean to use '$(echo "${lists[cmds]}" | sed -e 's/\^\|[\(]\|[\)]\|\$//g' -e 's/[\|]/\n/g' | grep "$1")'?"
					exit
				fi
				;;
		esac
	shift; done
}

__proc() {
	[[ -z "$states[format]" ]] && error "No format specified!" && exit
	# Process the format
	local built_regex="${states[format]}"
	local escs='';
	# '#' is used as a placeholder
	# Process escaped characters
	[[ "$built_regex" =~ '\' ]] && {
		verbose "Escaping * and %...";
		escs=true;
		built_regex="$(echo "$built_regex" | \
			sed -e 's/\(\\\*\)/!/g' \
					-e 's/\(\\%\)/@/g' \
		)";
		verbose "Current regex transformation: "$built_regex;
	}

	# Next wildchars
	[[ "$built_regex" =~ (\**) ]] && {
		verbose "Transforming wildcard characters...";
		built_regex="$(echo "$built_regex" | \
			sed -e 's/\./\\./g' \
					-e 's/\(\*\*\)/#/g' \
					-e 's/\(\*\)/\./g' \
					-e 's/#/'"$xwildchar"'/g' \
		)";
		verbose "Current regex transformation: "$built_regex;
	}
	
	# Next wilddigits
	[[ "$built_regex" =~ (%*) ]] && {
		verbose "Transforming digits...";
		built_regex="$(echo "$built_regex" | \
			sed -e 's/\(%%\)/#/g' \
					-e 's/\(%\)/[0-9]/g' \
					-e 's/#/'"$xwilddigit"'/g' \
		)";
		verbose "Current regex transformation: "$built_regex;
	}

	# Next whitespace
	[[ "$built_regex" =~ ( *) ]] && {
		verbose "Transforming spaces...";
		built_regex="$(echo "$built_regex" | \
			sed -e 's/ \+/'"$xwhitespace"'/g' \
					-e 's/\( \)/'"[[:space:]]"'/g' \
		)";
		verbose "Current regex transformation: "$built_regex;
	}

	# Lastly turn escaped characters back into their literals for use as that character in the regex
	[[ -n "$escs" ]] && {
		verbose "Swapping * and % back to their escaped forms...";
		built_regex="$(echo "$built_regex" | \
			sed -e 's/\(!\)/\\*/g' \
					-e 's/\(@\)/\\%/g' \
		)";
		verbose "Current regex transformation: "$built_regex;
	}

	# Echo out resulting regex
	verbose "Built regex: "$built_regex;
	echo "$built_regex"
}
